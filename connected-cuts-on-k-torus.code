def isMinimal(TG):
	Let Waiting = []

	Pick an edge E in G, assign direction arbitrarily
	Add the two Vs incident to E to Waiting

	While Waiting is not empty:
		Pop vertex V from Waiting
		Starting at an edge incident to V that has a direction already assigned:
			Try to assign directions alternating between inward and outward along the cyclic ordering.
			If we must assign a contradictory direction to an edge that already has a direction assigned:
				Return false 
		Add vertices incident to each edge that is newly assigned a direction to Waiting

	Return True (we had no problems)


def countDirectedCycles(TG):
	waitingEdges = TG.dirEdges
	cycles = []
	while waitingEdges is not empty:
		currentEdge = waitingEdges.pop()
		thisCycle = [currentEdge]
		while (currentEdge not in thisCycle):
			thisCycle.push(currentEdge)
			currentEdge = TG.nextDirEdge(TG.dirEdges[currentEdge][1],currentEdge)
		cycles.push(thisCycle)
	return len(cycles)
		

#For connected 2-cuts on a k-torus:
#----------------------------------

legitList = []

for graphs G that
	are a single loop, or
	( satisfy 4k >= |E| >= 2|V|, and
	  for all vertices v, deg(v) >=4, and
	  for all vertices v, and deg(v) is even ):

	for each possible cyclic ordering C on G:
		if not isMinimal(TG):
			continue
		n = countDirectedCycles(TG) 
		# n = number of boundary components
		g = 1 - 0.5*TG.eulerChar - 0.5*n
		if g+n-2 <= k: 
		#(i.e., glueing process doesn't introduce too many genera)
			legitList.append(G)
			break